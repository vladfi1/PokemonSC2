//Andromeda generated code @ Fri Aug 08 03:32:47 EDT 2014

struct Class{
	int Class____id;
	int Class____type;
	int Class__id;
	string Class__name;
	int[6] Class__vct;
};

struct Object{
	int Object____id;
	int Object____type;
};

struct Comparator{
	int Comparator____id;
	int Comparator____type;
};

struct Hasher{
	int Hasher____id;
	int Hasher____type;
};

struct Move{
	int Move____id;
	int Move____type;
	string Move__name;
	int Move__power;
	int Move__type;
	int Move__kind;
};

struct PokemonSpecies{
	int PokemonSpecies____id;
	int PokemonSpecies____type;
	string PokemonSpecies__name;
	int PokemonSpecies__hp;
	int PokemonSpecies__atk;
	int PokemonSpecies__def;
	int PokemonSpecies__satk;
	int PokemonSpecies__sdef;
	int PokemonSpecies__type1;
	int PokemonSpecies__type2;
	int PokemonSpecies__move;
};

struct Iterator{
	int Iterator____id;
	int Iterator____type;
	int AbstractListIterator__list_mult;
	int AbstractListIterator__nextIndex_mult;
	int AbstractListIterator__prevIndex;
	int AbstractListIterator__lastIndex;
};

struct Iterable{
	int Iterable____id;
	int Iterable____type;
	int ArraySet__list_mult;
	int ArraySet__size_mult;
	int ArrayList__size;
};

struct Map{
	int Map____id;
	int Map____type;
	int ArrayMap__list;
	int ArrayMap__size;
};

struct MapEntry{
	int MapEntry____id;
	int MapEntry____type;
	int MapEntry__key;
	int MapEntry__value;
};

struct Pokemon{
	int Pokemon____id;
	int Pokemon____type;
	int Pokemon__species;
	int Pokemon__level;
	int Pokemon__hp;
	int Pokemon__owner;
	unit Pokemon___unit;
};

struct Team{
	int Team____id;
	int Team____type;
	string Team__name;
	point Team__spawn;
	int Team__cpu;
	playergroup Team__group;
	int Team__trainers;
	int Team__enemy;
};

struct Trainer{
	int Trainer____id;
	int Trainer____type;
	int Trainer__player;
	int Trainer__team;
	int Trainer__pokemon;
};


//Allocator for class Class
int alloc___Class(int A__class);
//Deallocator for class Class
void dealloc___Class(int this);
//Allocator for class Object
int alloc___Object(int A__class);
//Deallocator for class Object
void dealloc___Object(int this);
//Allocator for class Comparator
int alloc___Comparator(int A__class);
//Deallocator for class Comparator
void dealloc___Comparator(int this);
//Virtual caller for PokemonComparator.compare
int vcall___compare(int this,int p1,int p2);
//Allocator for class Hasher
int alloc___Hasher(int A__class);
//Deallocator for class Hasher
void dealloc___Hasher(int this);
//Allocator for class Move
int alloc___Move(int A__class);
//Deallocator for class Move
void dealloc___Move(int this);
//Allocator for class PokemonSpecies
int alloc___PokemonSpecies(int A__class);
//Deallocator for class PokemonSpecies
void dealloc___PokemonSpecies(int this);
//Allocator for class Iterator
int alloc___Iterator(int A__class);
//Deallocator for class Iterator
void dealloc___Iterator(int this);
//Virtual caller for AbstractListIterator.hasNext
bool vcall___Iterator__hasNext(int this);
//Virtual caller for AbstractListIterator.next
int vcall___Iterator__next(int this);
//Allocator for class Iterable
int alloc___Iterable(int A__class);
//Deallocator for class Iterable
void dealloc___Iterable(int this);
//Virtual caller for ArraySet.getIterator
int vcall___Iterable__getIterator(int this);
//Virtual caller for ArraySet.size
int vcall___Set__size(int this);
//Virtual caller for ArraySet.add
bool vcall___Set__add(int this,int e);
//Virtual caller for ArrayList.size
int vcall___List__size(int this);
//Virtual caller for ArrayList.getIndex
int vcall___List__getIndex(int this,int index);
//Virtual caller for ArrayList.setIndex
void vcall___setIndex(int this,int index,int element);
//Virtual caller for ArrayList.addIndex
bool vcall___addIndex(int this,int index,int element);
//Virtual caller for ArrayList.removeIndex
int vcall___removeIndex(int this,int index);
//Allocator for class Map
int alloc___Map(int A__class);
//Deallocator for class Map
void dealloc___Map(int this);
//Virtual caller for ArrayMap.put
int vcall___Map__put(int this,int key,int value);
//Virtual caller for ArrayMap.getValue
int vcall___Map__getValue(int this,int key);
//Allocator for class MapEntry
int alloc___MapEntry(int A__class);
//Deallocator for class MapEntry
void dealloc___MapEntry(int this);
//Allocator for class Pokemon
int alloc___Pokemon(int A__class);
//Deallocator for class Pokemon
void dealloc___Pokemon(int this);
//Allocator for class Team
int alloc___Team(int A__class);
//Deallocator for class Team
void dealloc___Team(int this);
//Allocator for class Trainer
int alloc___Trainer(int A__class);
//Deallocator for class Trainer
void dealloc___Trainer(int this);
//Constructor for class Class
int new__Class(int A__class,int id,string name);
string Class__getName(int this);
int Class__getId(int this);
void s_System__error(string message);
void s_System__debug(string message);
void s_System__debug__1(string message,bool showIngame);
void s_System__print(string message);
string Player__toString(int this);
void Player__set__minerals(int this,int value);
bool Player__isActive(int this);
point Player__get__startLocation(int this);
//Static init
bool init___global1(bool A__1,bool A__2);
trigger s_trigger__create(string func);
void trigger__addEventTimer(trigger this,timer p2);
void trigger__addEventUnitAbility(trigger this,unitref p2,abilcmd p3,int p4,bool p5);
point point__translateXY(point this,fixed dx,fixed dy);
timer s_timer__create();
void timer__start(timer this,fixed duration,bool periodic,int timeType);
//Static init
bool init___global2(bool A__1,bool A__2);
string Type__toString(int this);
fixed Type__getAdvantage(int this,int defending);
//Static init
bool init___global3(bool A__1,bool A__2);
string Kind__toString(int this);
//Constructor for class Move
int new__Move(int A__class,string name,int power,int type,int kind);
string Move__toString(int this);
int s_PokemonSpecies__getSpecies();
int s_PokemonSpecies__fromString(string name);
//Constructor for class PokemonSpecies
int new__PokemonSpecies(int A__class,string name,int hp,int atk,int def,int satk,int sdef,int type1,int type2,int move);
//Constructor for class PokemonSpecies
int new__PokemonSpecies__1(int A__class,string name,int hp,int atk,int def,int satk,int sdef,int type,int move);
int AbstractList__getIterator(int this);
int AbstractList__getListIteratorAt(int this,int index);
//Constructor for class AbstractListIterator
int new__AbstractListIterator(int A__class,int list,int pos);
bool AbstractListIterator__hasNext(int this);
int AbstractListIterator__next(int this);
//Static init
bool init___global4(bool A__1,bool A__2);
void s_Heap__initHeap();
void s_Heap__initLevel(int level);
int s_Heap__level(int ptr);
int s_Heap__prev(int ptr);
int s_Heap__next(int ptr);
void s_Heap__setHeader(int ptr,int level,int prev,int next);
void s_Heap__setPrev(int ptr,int prev);
void s_Heap__setNext(int ptr,int next);
bool s_Heap__isEmpty(int level);
void s_Heap__add(int level,int ptr);
int s_Heap__remove(int level);
void s_Heap__remove__1(int level,int ptr);
int s_Heap__buddy(int level,int ptr);
int s_Heap__minLevel(int size);
int s_Heap__maxSize(int level);
int s_Heap__round(int size);
int s_Heap__malloc(int size);
void s_Heap__free(int ptr);
int s_Heap__realloc(int ptr,int size);
void s_Heap__copy(int src,int dest,int len);
//Constructor for class ArrayList
int new__ArrayList(int A__class);
//Constructor for class ArrayList
int new__ArrayList__1(int A__class,int capacity);
int ArrayList__size(int this);
bool ArrayList__setCapacity(int this,int capacity);
bool ArrayList__ensureCapacity(int this,int capacity);
int ArrayList__getIndex(int this,int index);
void ArrayList__setIndex(int this,int index,int element);
bool ArrayList__addLast(int this,int element);
bool ArrayList__addIndex(int this,int index,int element);
int ArrayList__removeIndex(int this,int index);
//Constructor for class ArraySet
int new__ArraySet(int A__class);
int ArraySet__size(int this);
void ArraySet__ensure(int this,int e);
bool ArraySet__add(int this,int e);
bool ArraySet__contains(int this,int e);
int ArraySet__getIterator(int this);
//Constructor for class ArraySetIterator
int new__ArraySetIterator(int A__class,int list);
bool ArraySetIterator__hasNext(int this);
int ArraySetIterator__next(int this);
//Constructor for class ArrayMap
int new__ArrayMap(int A__class);
void ArrayMap__ensure(int this,int key);
int ArrayMap__put(int this,int key,int value);
int ArrayMap__getValue(int this,int key);
playergroup s_playergroup__empty();
void playergroup__add(playergroup this,int p);
unit s_unit__create(string name,int options,int player,point position,fixed angle);
point unit__getPosition(unit this);
void unit__setInfoText(unit this,text p2,text p3,text p4);
void unit__setPropertyInt(unit this,int p2,int p3);
void unit__setCustomValue(unit this,int p2,fixed p3);
fixed unit__getCustomValue(unit this,int p2);
unitref unit__getUnitRef(unit this);
//Constructor for class Pokemon
int new__Pokemon(int A__class,int species,int level,int owner,point p);
int Pokemon__getStat(int this,int base);
int Pokemon__getHp(int this);
int Pokemon__getAtk(int this);
int Pokemon__getDef(int this);
int Pokemon__getSAtk(int this);
int Pokemon__getSDef(int this);
int Pokemon__damage(int this,int other);
fixed Pokemon__getTypeAdvantage(int this,int other);
unit Pokemon__getUnit(int this);
void Pokemon__setUnit(int this,unit u);
int Pokemon__clone(int this,int player,point spawn);
int PokemonComparator__compare(int this,int p1,int p2);
int PokemonHasher__hashCode(int this,int p);
bool PokemonHasher__equal(int this,int p1,int p2);
bool damageUnit(bool conditions,bool actions);
string abilcmd__getAbility(abilcmd this);
void makeRentalCenter(int player);
bool rent(bool conditions,bool actions);
void initTrainer(int player,int team);
//Static init
bool init___global5(bool A__1,bool A__2);
//Constructor for class Team
int new__Team(int A__class,string name,point spawn,int cpu);
int Team__size(int this);
string Team__toString(int this);
void Team__addTrainer(int this,int trainer);
int s_Trainer__getTrainer(int player);
//Constructor for class Trainer
int new__Trainer(int A__class,int player,int team);
void Trainer__addPokemon(int this,int species);
void s_Trainer__addPokemon__1(int player,int species);
//Static init
bool init___global6(bool A__1,bool A__2);
bool createUnitChat(bool b1,bool b2);
bool makeWave(bool b1,bool b2);
void waveHelper(int team,int dx);

int Class___allocPtr=1;
int Class___freePtr;
Class[31] Class___memory;
int[31] Class___freeStack;
int MC___Class;
int Object___allocPtr=1;
int Object___freePtr;
Object[2] Object___memory;
int[2] Object___freeStack;
int MC___Object;
int MC___System;
int Comparator___allocPtr=1;
int Comparator___freePtr;
Comparator[129] Comparator___memory;
int[129] Comparator___freeStack;
int MC___Comparator;
int Hasher___allocPtr=1;
int Hasher___freePtr;
Hasher[129] Hasher___memory;
int[129] Hasher___freeStack;
int MC___Hasher;
int MC___PlayerComparator;
int MC___PlayerHasher;
int MC___Math;
int Move___allocPtr=1;
int Move___freePtr;
Move[129] Move___memory;
int[129] Move___freeStack;
int MC___Move;
int PokemonSpecies___allocPtr=1;
int PokemonSpecies___freePtr;
PokemonSpecies[129] PokemonSpecies___memory;
int[129] PokemonSpecies___freeStack;
int MC___PokemonSpecies;
int Iterator___allocPtr=1;
int Iterator___freePtr;
Iterator[129] Iterator___memory;
int[129] Iterator___freeStack;
int MC___Iterator;
int Iterable___allocPtr=1;
int Iterable___freePtr;
Iterable[129] Iterable___memory;
int[129] Iterable___freeStack;
int MC___Iterable;
int MC___Set;
int MC___ListIterator;
int MC___List;
int MC___AbstractList;
int MC___AbstractListIterator;
int MC___Heap;
int MC___Array;
int MC___ArrayList;
int MC___ArraySet;
int MC___ArraySetIterator;
int Map___allocPtr=1;
int Map___freePtr;
Map[129] Map___memory;
int[129] Map___freeStack;
int MC___Map;
int MapEntry___allocPtr=1;
int MapEntry___freePtr;
MapEntry[129] MapEntry___memory;
int[129] MapEntry___freeStack;
int MC___MapEntry;
int MC___ArrayMap;
int Pokemon___allocPtr=1;
int Pokemon___freePtr;
Pokemon[129] Pokemon___memory;
int[129] Pokemon___freeStack;
int MC___Pokemon;
int MC___PokemonComparator;
int MC___PokemonHasher;
int Team___allocPtr=1;
int Team___freePtr;
Team[129] Team___memory;
int[129] Team___freeStack;
int MC___Team;
int Trainer___allocPtr=1;
int Trainer___freePtr;
Trainer[129] Trainer___memory;
int[129] Trainer___freeStack;
int MC___Trainer;

playergroup s_System__ALL_PLAYERS = PlayerGroupAll();
string[99] s_Key__displayText;
const int s_Type__NUM_TYPES = 17;
string[17] s_Type__type_names;
fixed[17][17] s_Type__typeChart;
const int s_Type__NONE = -1;
const int s_Type__NORMAL = 0;
const int s_Type__FIRE = 1;
const int s_Type__WATER = 2;
const int s_Type__ELECTRIC = 3;
const int s_Type__GRASS = 4;
const int s_Type__ICE = 5;
const int s_Type__FIGHTING = 6;
const int s_Type__POISON = 7;
const int s_Type__GROUND = 8;
const int s_Type__FLYING = 9;
const int s_Type__PSYCHIC = 10;
const int s_Type__BUG = 11;
const int s_Type__ROCK = 12;
const int s_Type__GHOST = 13;
const int s_Type__DRAGON = 14;
const int s_Type__DARK = 15;
const int s_Type__STEEL = 16;
const int s_Kind__PHYSICAL = 0;
const int s_Kind__SPECIAL = 1;
string[2] s_Kind__kind_names;
int s_Move__GENERIC = new__Move(MC___Move,"Generic", 50, 0, 0);
int s_Move__FLAMETHROWER = new__Move(MC___Move,"Flamethrower", 95, 1, 1);
int s_Move__SHADOW_BALL = new__Move(MC___Move,"Shadow Ball", 80, 13, 1);
int s_Move__HYDRO_PUMP = new__Move(MC___Move,"Hydro Pump", 120, 2, 1);
int s_Move__WATER_GUN = new__Move(MC___Move,"Water Gun", 40, 2, 1);
int s_Move__RAZOR_LEAF = new__Move(MC___Move,"Razor Leaf", 55, 4, 0);
int s_PokemonSpecies__species = 0;
int[16412] s_Heap__array;
int[15] s_Heap__head;
int[15] s_Heap__count;
int s_Pokemon__comparator = alloc___Comparator(MC___PokemonComparator);
int s_Pokemon__hasher = alloc___Hasher(MC___PokemonHasher);
int s_Team__left;
int s_Team__right;
int s_Trainer__trainers;

void A__classInit(){
	int A__class;
	A__class=new__Class(1,1,"Class");
	MC___Class=A__class;
	A__class=new__Class(2,2,"Object");
	MC___Object=A__class;
	A__class=new__Class(3,3,"System");
	MC___System=A__class;
	A__class=new__Class(6,6,"Comparator");
	MC___Comparator=A__class;
	Class___memory[A__class].Class__vct[0]=-1;
	A__class=new__Class(9,9,"Hasher");
	MC___Hasher=A__class;
	A__class=new__Class(4,4,"PlayerComparator");
	MC___PlayerComparator=A__class;
	Class___memory[A__class].Class__vct[0]=-1;
	A__class=new__Class(7,7,"PlayerHasher");
	MC___PlayerHasher=A__class;
	A__class=new__Class(10,10,"Math");
	MC___Math=A__class;
	A__class=new__Class(11,11,"Move");
	MC___Move=A__class;
	A__class=new__Class(12,12,"PokemonSpecies");
	MC___PokemonSpecies=A__class;
	A__class=new__Class(16,16,"Iterator");
	MC___Iterator=A__class;
	Class___memory[A__class].Class__vct[0]=-1;
	Class___memory[A__class].Class__vct[1]=-1;
	A__class=new__Class(23,23,"Iterable");
	MC___Iterable=A__class;
	Class___memory[A__class].Class__vct[0]=-1;
	A__class=new__Class(18,18,"Set");
	MC___Set=A__class;
	Class___memory[A__class].Class__vct[0]=-1;
	Class___memory[A__class].Class__vct[1]=-1;
	Class___memory[A__class].Class__vct[2]=-1;
	A__class=new__Class(14,14,"ListIterator");
	MC___ListIterator=A__class;
	Class___memory[A__class].Class__vct[0]=-1;
	Class___memory[A__class].Class__vct[1]=-1;
	A__class=new__Class(22,22,"List");
	MC___List=A__class;
	Class___memory[A__class].Class__vct[0]=-1;
	Class___memory[A__class].Class__vct[1]=-1;
	Class___memory[A__class].Class__vct[2]=-1;
	Class___memory[A__class].Class__vct[3]=-1;
	Class___memory[A__class].Class__vct[4]=-1;
	Class___memory[A__class].Class__vct[5]=-1;
	A__class=new__Class(21,21,"AbstractList");
	MC___AbstractList=A__class;
	Class___memory[A__class].Class__vct[0]=1;
	Class___memory[A__class].Class__vct[1]=-1;
	Class___memory[A__class].Class__vct[2]=-1;
	Class___memory[A__class].Class__vct[3]=-1;
	Class___memory[A__class].Class__vct[4]=-1;
	Class___memory[A__class].Class__vct[5]=-1;
	A__class=new__Class(13,13,"AbstractListIterator");
	MC___AbstractListIterator=A__class;
	Class___memory[A__class].Class__vct[0]=0;
	Class___memory[A__class].Class__vct[1]=0;
	A__class=new__Class(24,24,"Heap");
	MC___Heap=A__class;
	A__class=new__Class(19,19,"Array");
	MC___Array=A__class;
	Class___memory[A__class].Class__vct[0]=1;
	Class___memory[A__class].Class__vct[1]=-1;
	Class___memory[A__class].Class__vct[2]=-1;
	Class___memory[A__class].Class__vct[3]=-1;
	Class___memory[A__class].Class__vct[4]=-1;
	Class___memory[A__class].Class__vct[5]=-1;
	A__class=new__Class(20,20,"ArrayList");
	MC___ArrayList=A__class;
	Class___memory[A__class].Class__vct[0]=1;
	Class___memory[A__class].Class__vct[1]=0;
	Class___memory[A__class].Class__vct[2]=0;
	Class___memory[A__class].Class__vct[3]=0;
	Class___memory[A__class].Class__vct[4]=0;
	Class___memory[A__class].Class__vct[5]=0;
	A__class=new__Class(17,17,"ArraySet");
	MC___ArraySet=A__class;
	Class___memory[A__class].Class__vct[0]=0;
	Class___memory[A__class].Class__vct[1]=0;
	Class___memory[A__class].Class__vct[2]=0;
	A__class=new__Class(15,15,"ArraySetIterator");
	MC___ArraySetIterator=A__class;
	Class___memory[A__class].Class__vct[0]=1;
	Class___memory[A__class].Class__vct[1]=1;
	A__class=new__Class(26,26,"Map");
	MC___Map=A__class;
	Class___memory[A__class].Class__vct[0]=-1;
	Class___memory[A__class].Class__vct[1]=-1;
	A__class=new__Class(27,27,"MapEntry");
	MC___MapEntry=A__class;
	A__class=new__Class(25,25,"ArrayMap");
	MC___ArrayMap=A__class;
	Class___memory[A__class].Class__vct[0]=0;
	Class___memory[A__class].Class__vct[1]=0;
	A__class=new__Class(28,28,"Pokemon");
	MC___Pokemon=A__class;
	A__class=new__Class(5,5,"PokemonComparator");
	MC___PokemonComparator=A__class;
	Class___memory[A__class].Class__vct[0]=0;
	A__class=new__Class(8,8,"PokemonHasher");
	MC___PokemonHasher=A__class;
	A__class=new__Class(29,29,"Team");
	MC___Team=A__class;
	A__class=new__Class(30,30,"Trainer");
	MC___Trainer=A__class;
}


//Allocator for class Class
int alloc___Class(int A__class){
	int this;
	if(Class___freePtr>0){
		Class___freePtr-=1;
		this=Class___freeStack[Class___freePtr];
	}else if(Class___allocPtr<31){
		this=Class___allocPtr;
		Class___allocPtr+=1;
	}else{
		s_System__error("Instance limit reached for class Class. Allocation failed!");
		return 0;
	}
	Class___memory[this].Class____type=A__class;
	Class___memory[this].Class____id=(A__class<<24)|this;
	return this;
}

//Deallocator for class Class
void dealloc___Class(int this){
	if(Class___memory[this].Class____id==0){
		s_System__error("Double free of class Class");
		return;
	}
	Class___memory[this].Class____id=0;
	Class___memory[this].Class____type=0;
	Class___freeStack[Class___freePtr]=this;
	Class___freePtr+=1;
}

//Allocator for class Object
int alloc___Object(int A__class){
	int this;
	if(Object___freePtr>0){
		Object___freePtr-=1;
		this=Object___freeStack[Object___freePtr];
	}else if(Object___allocPtr<2){
		this=Object___allocPtr;
		Object___allocPtr+=1;
	}else{
		s_System__error("Instance limit reached for class Object. Allocation failed!");
		return 0;
	}
	Object___memory[this].Object____type=A__class;
	Object___memory[this].Object____id=(A__class<<24)|this;
	return this;
}

//Deallocator for class Object
void dealloc___Object(int this){
	if(Object___memory[this].Object____id==0){
		s_System__error("Double free of class Object");
		return;
	}
	Object___memory[this].Object____id=0;
	Object___memory[this].Object____type=0;
	Object___freeStack[Object___freePtr]=this;
	Object___freePtr+=1;
}

//Allocator for class Comparator
int alloc___Comparator(int A__class){
	int this;
	if(Comparator___freePtr>0){
		Comparator___freePtr-=1;
		this=Comparator___freeStack[Comparator___freePtr];
	}else if(Comparator___allocPtr<129){
		this=Comparator___allocPtr;
		Comparator___allocPtr+=1;
	}else{
		s_System__error("Instance limit reached for class Comparator. Allocation failed!");
		return 0;
	}
	Comparator___memory[this].Comparator____type=A__class;
	Comparator___memory[this].Comparator____id=(A__class<<24)|this;
	return this;
}

//Deallocator for class Comparator
void dealloc___Comparator(int this){
	if(Comparator___memory[this].Comparator____id==0){
		s_System__error("Double free of class Comparator");
		return;
	}
	Comparator___memory[this].Comparator____id=0;
	Comparator___memory[this].Comparator____type=0;
	Comparator___freeStack[Comparator___freePtr]=this;
	Comparator___freePtr+=1;
}

//Virtual caller for PokemonComparator.compare
int vcall___compare(int this,int p1,int p2){
	int cl=Class___memory[Comparator___memory[this].Comparator____type].Class__vct[0];
	return PokemonComparator__compare(this,p1,p2);
}

//Allocator for class Hasher
int alloc___Hasher(int A__class){
	int this;
	if(Hasher___freePtr>0){
		Hasher___freePtr-=1;
		this=Hasher___freeStack[Hasher___freePtr];
	}else if(Hasher___allocPtr<129){
		this=Hasher___allocPtr;
		Hasher___allocPtr+=1;
	}else{
		s_System__error("Instance limit reached for class Hasher. Allocation failed!");
		return 0;
	}
	Hasher___memory[this].Hasher____type=A__class;
	Hasher___memory[this].Hasher____id=(A__class<<24)|this;
	return this;
}

//Deallocator for class Hasher
void dealloc___Hasher(int this){
	if(Hasher___memory[this].Hasher____id==0){
		s_System__error("Double free of class Hasher");
		return;
	}
	Hasher___memory[this].Hasher____id=0;
	Hasher___memory[this].Hasher____type=0;
	Hasher___freeStack[Hasher___freePtr]=this;
	Hasher___freePtr+=1;
}

//Allocator for class Move
int alloc___Move(int A__class){
	int this;
	if(Move___freePtr>0){
		Move___freePtr-=1;
		this=Move___freeStack[Move___freePtr];
	}else if(Move___allocPtr<129){
		this=Move___allocPtr;
		Move___allocPtr+=1;
	}else{
		s_System__error("Instance limit reached for class Move. Allocation failed!");
		return 0;
	}
	Move___memory[this].Move____type=A__class;
	Move___memory[this].Move____id=(A__class<<24)|this;
	return this;
}

//Deallocator for class Move
void dealloc___Move(int this){
	if(Move___memory[this].Move____id==0){
		s_System__error("Double free of class Move");
		return;
	}
	Move___memory[this].Move____id=0;
	Move___memory[this].Move____type=0;
	Move___freeStack[Move___freePtr]=this;
	Move___freePtr+=1;
}

//Allocator for class PokemonSpecies
int alloc___PokemonSpecies(int A__class){
	int this;
	if(PokemonSpecies___freePtr>0){
		PokemonSpecies___freePtr-=1;
		this=PokemonSpecies___freeStack[PokemonSpecies___freePtr];
	}else if(PokemonSpecies___allocPtr<129){
		this=PokemonSpecies___allocPtr;
		PokemonSpecies___allocPtr+=1;
	}else{
		s_System__error("Instance limit reached for class PokemonSpecies. Allocation failed!");
		return 0;
	}
	PokemonSpecies___memory[this].PokemonSpecies____type=A__class;
	PokemonSpecies___memory[this].PokemonSpecies____id=(A__class<<24)|this;
	return this;
}

//Deallocator for class PokemonSpecies
void dealloc___PokemonSpecies(int this){
	if(PokemonSpecies___memory[this].PokemonSpecies____id==0){
		s_System__error("Double free of class PokemonSpecies");
		return;
	}
	PokemonSpecies___memory[this].PokemonSpecies____id=0;
	PokemonSpecies___memory[this].PokemonSpecies____type=0;
	PokemonSpecies___freeStack[PokemonSpecies___freePtr]=this;
	PokemonSpecies___freePtr+=1;
}

//Allocator for class Iterator
int alloc___Iterator(int A__class){
	int this;
	if(Iterator___freePtr>0){
		Iterator___freePtr-=1;
		this=Iterator___freeStack[Iterator___freePtr];
	}else if(Iterator___allocPtr<129){
		this=Iterator___allocPtr;
		Iterator___allocPtr+=1;
	}else{
		s_System__error("Instance limit reached for class Iterator. Allocation failed!");
		return 0;
	}
	Iterator___memory[this].Iterator____type=A__class;
	Iterator___memory[this].Iterator____id=(A__class<<24)|this;
	return this;
}

//Deallocator for class Iterator
void dealloc___Iterator(int this){
	if(Iterator___memory[this].Iterator____id==0){
		s_System__error("Double free of class Iterator");
		return;
	}
	Iterator___memory[this].Iterator____id=0;
	Iterator___memory[this].Iterator____type=0;
	Iterator___freeStack[Iterator___freePtr]=this;
	Iterator___freePtr+=1;
}

//Virtual caller for AbstractListIterator.hasNext
bool vcall___Iterator__hasNext(int this){
	int cl=Class___memory[Iterator___memory[this].Iterator____type].Class__vct[0];
	if(cl<1){
		return AbstractListIterator__hasNext(this);
	}else{
		return ArraySetIterator__hasNext(this);
	}
}

//Virtual caller for AbstractListIterator.next
int vcall___Iterator__next(int this){
	int cl=Class___memory[Iterator___memory[this].Iterator____type].Class__vct[1];
	if(cl<1){
		return AbstractListIterator__next(this);
	}else{
		return ArraySetIterator__next(this);
	}
}

//Allocator for class Iterable
int alloc___Iterable(int A__class){
	int this;
	if(Iterable___freePtr>0){
		Iterable___freePtr-=1;
		this=Iterable___freeStack[Iterable___freePtr];
	}else if(Iterable___allocPtr<129){
		this=Iterable___allocPtr;
		Iterable___allocPtr+=1;
	}else{
		s_System__error("Instance limit reached for class Iterable. Allocation failed!");
		return 0;
	}
	Iterable___memory[this].Iterable____type=A__class;
	Iterable___memory[this].Iterable____id=(A__class<<24)|this;
	return this;
}

//Deallocator for class Iterable
void dealloc___Iterable(int this){
	if(Iterable___memory[this].Iterable____id==0){
		s_System__error("Double free of class Iterable");
		return;
	}
	Iterable___memory[this].Iterable____id=0;
	Iterable___memory[this].Iterable____type=0;
	Iterable___freeStack[Iterable___freePtr]=this;
	Iterable___freePtr+=1;
}

//Virtual caller for ArraySet.getIterator
int vcall___Iterable__getIterator(int this){
	int cl=Class___memory[Iterable___memory[this].Iterable____type].Class__vct[0];
	if(cl<1){
		return ArraySet__getIterator(this);
	}else{
		return AbstractList__getIterator(this);
	}
}

//Virtual caller for ArraySet.size
int vcall___Set__size(int this){
	int cl=Class___memory[Iterable___memory[this].Iterable____type].Class__vct[1];
	return ArraySet__size(this);
}

//Virtual caller for ArraySet.add
bool vcall___Set__add(int this,int e){
	int cl=Class___memory[Iterable___memory[this].Iterable____type].Class__vct[2];
	return ArraySet__add(this,e);
}

//Virtual caller for ArrayList.size
int vcall___List__size(int this){
	int cl=Class___memory[Iterable___memory[this].Iterable____type].Class__vct[1];
	return ArrayList__size(this);
}

//Virtual caller for ArrayList.getIndex
int vcall___List__getIndex(int this,int index){
	int cl=Class___memory[Iterable___memory[this].Iterable____type].Class__vct[2];
	return ArrayList__getIndex(this,index);
}

//Virtual caller for ArrayList.setIndex
void vcall___setIndex(int this,int index,int element){
	int cl=Class___memory[Iterable___memory[this].Iterable____type].Class__vct[3];
	ArrayList__setIndex(this,index,element);
}

//Virtual caller for ArrayList.addIndex
bool vcall___addIndex(int this,int index,int element){
	int cl=Class___memory[Iterable___memory[this].Iterable____type].Class__vct[4];
	return ArrayList__addIndex(this,index,element);
}

//Virtual caller for ArrayList.removeIndex
int vcall___removeIndex(int this,int index){
	int cl=Class___memory[Iterable___memory[this].Iterable____type].Class__vct[5];
	return ArrayList__removeIndex(this,index);
}

//Allocator for class Map
int alloc___Map(int A__class){
	int this;
	if(Map___freePtr>0){
		Map___freePtr-=1;
		this=Map___freeStack[Map___freePtr];
	}else if(Map___allocPtr<129){
		this=Map___allocPtr;
		Map___allocPtr+=1;
	}else{
		s_System__error("Instance limit reached for class Map. Allocation failed!");
		return 0;
	}
	Map___memory[this].Map____type=A__class;
	Map___memory[this].Map____id=(A__class<<24)|this;
	return this;
}

//Deallocator for class Map
void dealloc___Map(int this){
	if(Map___memory[this].Map____id==0){
		s_System__error("Double free of class Map");
		return;
	}
	Map___memory[this].Map____id=0;
	Map___memory[this].Map____type=0;
	Map___freeStack[Map___freePtr]=this;
	Map___freePtr+=1;
}

//Virtual caller for ArrayMap.put
int vcall___Map__put(int this,int key,int value){
	int cl=Class___memory[Map___memory[this].Map____type].Class__vct[0];
	return ArrayMap__put(this,key,value);
}

//Virtual caller for ArrayMap.getValue
int vcall___Map__getValue(int this,int key){
	int cl=Class___memory[Map___memory[this].Map____type].Class__vct[1];
	return ArrayMap__getValue(this,key);
}

//Allocator for class MapEntry
int alloc___MapEntry(int A__class){
	int this;
	if(MapEntry___freePtr>0){
		MapEntry___freePtr-=1;
		this=MapEntry___freeStack[MapEntry___freePtr];
	}else if(MapEntry___allocPtr<129){
		this=MapEntry___allocPtr;
		MapEntry___allocPtr+=1;
	}else{
		s_System__error("Instance limit reached for class MapEntry. Allocation failed!");
		return 0;
	}
	MapEntry___memory[this].MapEntry____type=A__class;
	MapEntry___memory[this].MapEntry____id=(A__class<<24)|this;
	return this;
}

//Deallocator for class MapEntry
void dealloc___MapEntry(int this){
	if(MapEntry___memory[this].MapEntry____id==0){
		s_System__error("Double free of class MapEntry");
		return;
	}
	MapEntry___memory[this].MapEntry____id=0;
	MapEntry___memory[this].MapEntry____type=0;
	MapEntry___freeStack[MapEntry___freePtr]=this;
	MapEntry___freePtr+=1;
}

//Allocator for class Pokemon
int alloc___Pokemon(int A__class){
	int this;
	if(Pokemon___freePtr>0){
		Pokemon___freePtr-=1;
		this=Pokemon___freeStack[Pokemon___freePtr];
	}else if(Pokemon___allocPtr<129){
		this=Pokemon___allocPtr;
		Pokemon___allocPtr+=1;
	}else{
		s_System__error("Instance limit reached for class Pokemon. Allocation failed!");
		return 0;
	}
	Pokemon___memory[this].Pokemon____type=A__class;
	Pokemon___memory[this].Pokemon____id=(A__class<<24)|this;
	return this;
}

//Deallocator for class Pokemon
void dealloc___Pokemon(int this){
	if(Pokemon___memory[this].Pokemon____id==0){
		s_System__error("Double free of class Pokemon");
		return;
	}
	Pokemon___memory[this].Pokemon____id=0;
	Pokemon___memory[this].Pokemon____type=0;
	Pokemon___freeStack[Pokemon___freePtr]=this;
	Pokemon___freePtr+=1;
}

//Allocator for class Team
int alloc___Team(int A__class){
	int this;
	if(Team___freePtr>0){
		Team___freePtr-=1;
		this=Team___freeStack[Team___freePtr];
	}else if(Team___allocPtr<129){
		this=Team___allocPtr;
		Team___allocPtr+=1;
	}else{
		s_System__error("Instance limit reached for class Team. Allocation failed!");
		return 0;
	}
	Team___memory[this].Team____type=A__class;
	Team___memory[this].Team____id=(A__class<<24)|this;
	return this;
}

//Deallocator for class Team
void dealloc___Team(int this){
	if(Team___memory[this].Team____id==0){
		s_System__error("Double free of class Team");
		return;
	}
	Team___memory[this].Team____id=0;
	Team___memory[this].Team____type=0;
	Team___freeStack[Team___freePtr]=this;
	Team___freePtr+=1;
}

//Allocator for class Trainer
int alloc___Trainer(int A__class){
	int this;
	if(Trainer___freePtr>0){
		Trainer___freePtr-=1;
		this=Trainer___freeStack[Trainer___freePtr];
	}else if(Trainer___allocPtr<129){
		this=Trainer___allocPtr;
		Trainer___allocPtr+=1;
	}else{
		s_System__error("Instance limit reached for class Trainer. Allocation failed!");
		return 0;
	}
	Trainer___memory[this].Trainer____type=A__class;
	Trainer___memory[this].Trainer____id=(A__class<<24)|this;
	return this;
}

//Deallocator for class Trainer
void dealloc___Trainer(int this){
	if(Trainer___memory[this].Trainer____id==0){
		s_System__error("Double free of class Trainer");
		return;
	}
	Trainer___memory[this].Trainer____id=0;
	Trainer___memory[this].Trainer____type=0;
	Trainer___freeStack[Trainer___freePtr]=this;
	Trainer___freePtr+=1;
}

//Constructor for class Class
int new__Class(int A__class,int id,string name){
	int this=alloc___Class(A__class);
	Class___memory[this].Class__id = id;
	Class___memory[this].Class__name = name;
	return this;
}

string Class__getName(int this){
	return Class___memory[this].Class__name;
}

int Class__getId(int this){
	return Class___memory[this].Class__id;
}

void s_System__error(string message){
	TriggerDebugOutput(1, StringToText("ERROR: " + message), false);
	UIDisplayMessage(s_System__ALL_PLAYERS, 4, StringToText("ERROR: " + message));
}

void s_System__debug(string message){
	TriggerDebugOutput(1, StringToText(message), true);
}

void s_System__debug__1(string message,bool showIngame){
	TriggerDebugOutput(1, StringToText(message), showIngame);
}

void s_System__print(string message){
	UIDisplayMessage(s_System__ALL_PLAYERS, 7, StringToText(message));
}

string Player__toString(int this){
	return IntToString(this);
}

void Player__set__minerals(int this,int value){
	PlayerModifyPropertyInt(this, 0, 0, value);
}

bool Player__isActive(int this){
	return PlayerStatus(this) == 1;
}

point Player__get__startLocation(int this){
	return PlayerStartLocation(this);
}

//Static init
bool init___global1(bool A__1,bool A__2){
	s_Key__displayText[0] = "SHIFT";
	s_Key__displayText[1] = "CTRL";
	s_Key__displayText[2] = "ALT";
	s_Key__displayText[3] = "0";
	s_Key__displayText[4] = "1";
	s_Key__displayText[5] = "2";
	s_Key__displayText[6] = "3";
	s_Key__displayText[7] = "4";
	s_Key__displayText[8] = "5";
	s_Key__displayText[9] = "6";
	s_Key__displayText[10] = "7";
	s_Key__displayText[11] = "8";
	s_Key__displayText[12] = "9";
	s_Key__displayText[13] = "A";
	s_Key__displayText[14] = "B";
	s_Key__displayText[15] = "C";
	s_Key__displayText[16] = "D";
	s_Key__displayText[17] = "E";
	s_Key__displayText[18] = "F";
	s_Key__displayText[19] = "G";
	s_Key__displayText[20] = "H";
	s_Key__displayText[21] = "I";
	s_Key__displayText[22] = "J";
	s_Key__displayText[23] = "K";
	s_Key__displayText[24] = "L";
	s_Key__displayText[25] = "M";
	s_Key__displayText[26] = "N";
	s_Key__displayText[27] = "O";
	s_Key__displayText[28] = "P";
	s_Key__displayText[29] = "Q";
	s_Key__displayText[30] = "R";
	s_Key__displayText[31] = "S";
	s_Key__displayText[32] = "T";
	s_Key__displayText[33] = "U";
	s_Key__displayText[34] = "V";
	s_Key__displayText[35] = "W";
	s_Key__displayText[36] = "X";
	s_Key__displayText[37] = "Y";
	s_Key__displayText[38] = "Z";
	s_Key__displayText[39] = " ";
	s_Key__displayText[40] = "`";
	s_Key__displayText[41] = "NUM0";
	s_Key__displayText[42] = "NUM1";
	s_Key__displayText[43] = "NUM2";
	s_Key__displayText[44] = "NUM3";
	s_Key__displayText[45] = "NUM4";
	s_Key__displayText[46] = "NUM5";
	s_Key__displayText[47] = "NUM6";
	s_Key__displayText[48] = "NUM7";
	s_Key__displayText[49] = "NUM8";
	s_Key__displayText[50] = "NUM9";
	s_Key__displayText[51] = "NUM+";
	s_Key__displayText[52] = "NUM-";
	s_Key__displayText[53] = "NUM*";
	s_Key__displayText[54] = "NUM/";
	s_Key__displayText[55] = "NUM.";
	s_Key__displayText[56] = "=";
	s_Key__displayText[57] = "-";
	s_Key__displayText[58] = "(";
	s_Key__displayText[59] = ")";
	s_Key__displayText[60] = "\\";
	s_Key__displayText[61] = ";";
	s_Key__displayText[62] = "'";
	s_Key__displayText[63] = ",";
	s_Key__displayText[64] = ".";
	s_Key__displayText[65] = "/";
	s_Key__displayText[66] = "ESC";
	s_Key__displayText[67] = "\n";
	s_Key__displayText[68] = "BACKSPACE";
	s_Key__displayText[69] = "\t";
	s_Key__displayText[70] = "LEFT";
	s_Key__displayText[71] = "UP";
	s_Key__displayText[72] = "RIGHT";
	s_Key__displayText[73] = "DOWN";
	s_Key__displayText[74] = "INSERT";
	s_Key__displayText[75] = "DELETE";
	s_Key__displayText[76] = "HOME";
	s_Key__displayText[77] = "END";
	s_Key__displayText[78] = "PAGEUP";
	s_Key__displayText[79] = "PAGEDOWN";
	s_Key__displayText[80] = "CAPSLOCK";
	s_Key__displayText[81] = "NUMLOCK";
	s_Key__displayText[82] = "SCROLLLOCK";
	s_Key__displayText[83] = "PAUSE";
	s_Key__displayText[84] = "PRINT";
	s_Key__displayText[85] = ">>";
	s_Key__displayText[86] = "<<";
	s_Key__displayText[87] = "F1";
	s_Key__displayText[88] = "F2";
	s_Key__displayText[89] = "F3";
	s_Key__displayText[90] = "F4";
	s_Key__displayText[91] = "F5";
	s_Key__displayText[92] = "F6";
	s_Key__displayText[93] = "F7";
	s_Key__displayText[94] = "F8";
	s_Key__displayText[95] = "F9";
	s_Key__displayText[96] = "F10";
	s_Key__displayText[97] = "F11";
	s_Key__displayText[98] = "F12";
	return true;
}

trigger s_trigger__create(string func){
	return TriggerCreate(func);
}

void trigger__addEventTimer(trigger this,timer p2){
	TriggerAddEventTimer(this, p2);
}

void trigger__addEventUnitAbility(trigger this,unitref p2,abilcmd p3,int p4,bool p5){
	TriggerAddEventUnitAbility(this, p2, p3, p4, p5);
}

point point__translateXY(point this,fixed dx,fixed dy){
	return PointWithOffset(this, dx, dy);
}

timer s_timer__create(){
	return TimerCreate();
}

void timer__start(timer this,fixed duration,bool periodic,int timeType){
	TimerStart(this, duration, periodic, timeType);
}

//Static init
bool init___global2(bool A__1,bool A__2){
	s_Type__type_names[0] = "normal";
	s_Type__type_names[1] = "fire";
	s_Type__type_names[2] = "water";
	s_Type__type_names[3] = "electric";
	s_Type__type_names[4] = "grass";
	s_Type__type_names[5] = "ice";
	s_Type__type_names[6] = "fighting";
	s_Type__type_names[7] = "poison";
	s_Type__type_names[8] = "ground";
	s_Type__type_names[9] = "flying";
	s_Type__type_names[10] = "psychic";
	s_Type__type_names[11] = "bug";
	s_Type__type_names[12] = "rock";
	s_Type__type_names[13] = "ghost";
	s_Type__type_names[14] = "dragon";
	s_Type__type_names[15] = "dark";
	s_Type__type_names[16] = "steel";
	s_Type__typeChart[0][0] = 1.0;
	s_Type__typeChart[0][1] = 1.0;
	s_Type__typeChart[0][2] = 1.0;
	s_Type__typeChart[0][3] = 1.0;
	s_Type__typeChart[0][4] = 1.0;
	s_Type__typeChart[0][5] = 1.0;
	s_Type__typeChart[0][6] = 1.0;
	s_Type__typeChart[0][7] = 1.0;
	s_Type__typeChart[0][8] = 1.0;
	s_Type__typeChart[0][9] = 1.0;
	s_Type__typeChart[0][10] = 1.0;
	s_Type__typeChart[0][11] = 1.0;
	s_Type__typeChart[0][12] = 0.5;
	s_Type__typeChart[0][13] = 0.0;
	s_Type__typeChart[0][14] = 1.0;
	s_Type__typeChart[0][15] = 1.0;
	s_Type__typeChart[0][16] = 0.5;
	s_Type__typeChart[1][0] = 1.0;
	s_Type__typeChart[1][1] = 0.5;
	s_Type__typeChart[1][2] = 0.5;
	s_Type__typeChart[1][3] = 1.0;
	s_Type__typeChart[1][4] = 2.0;
	s_Type__typeChart[1][5] = 2.0;
	s_Type__typeChart[1][6] = 1.0;
	s_Type__typeChart[1][7] = 1.0;
	s_Type__typeChart[1][8] = 1.0;
	s_Type__typeChart[1][9] = 1.0;
	s_Type__typeChart[1][10] = 1.0;
	s_Type__typeChart[1][11] = 2.0;
	s_Type__typeChart[1][12] = 0.5;
	s_Type__typeChart[1][13] = 1.0;
	s_Type__typeChart[1][14] = 0.5;
	s_Type__typeChart[1][15] = 1.0;
	s_Type__typeChart[1][16] = 2.0;
	s_Type__typeChart[2][0] = 1.0;
	s_Type__typeChart[2][1] = 2.0;
	s_Type__typeChart[2][2] = 0.5;
	s_Type__typeChart[2][3] = 1.0;
	s_Type__typeChart[2][4] = 0.5;
	s_Type__typeChart[2][5] = 1.0;
	s_Type__typeChart[2][6] = 1.0;
	s_Type__typeChart[2][7] = 1.0;
	s_Type__typeChart[2][8] = 2.0;
	s_Type__typeChart[2][9] = 1.0;
	s_Type__typeChart[2][10] = 1.0;
	s_Type__typeChart[2][11] = 1.0;
	s_Type__typeChart[2][12] = 2.0;
	s_Type__typeChart[2][13] = 1.0;
	s_Type__typeChart[2][14] = 0.5;
	s_Type__typeChart[2][15] = 1.0;
	s_Type__typeChart[2][16] = 1.0;
	s_Type__typeChart[3][0] = 1.0;
	s_Type__typeChart[3][1] = 1.0;
	s_Type__typeChart[3][2] = 2.0;
	s_Type__typeChart[3][3] = 0.5;
	s_Type__typeChart[3][4] = 0.5;
	s_Type__typeChart[3][5] = 1.0;
	s_Type__typeChart[3][6] = 1.0;
	s_Type__typeChart[3][7] = 1.0;
	s_Type__typeChart[3][8] = 0.0;
	s_Type__typeChart[3][9] = 2.0;
	s_Type__typeChart[3][10] = 1.0;
	s_Type__typeChart[3][11] = 1.0;
	s_Type__typeChart[3][12] = 1.0;
	s_Type__typeChart[3][13] = 1.0;
	s_Type__typeChart[3][14] = 0.5;
	s_Type__typeChart[3][15] = 1.0;
	s_Type__typeChart[3][16] = 1.0;
	s_Type__typeChart[4][0] = 1.0;
	s_Type__typeChart[4][1] = 0.5;
	s_Type__typeChart[4][2] = 2.0;
	s_Type__typeChart[4][3] = 1.0;
	s_Type__typeChart[4][4] = 0.5;
	s_Type__typeChart[4][5] = 1.0;
	s_Type__typeChart[4][6] = 1.0;
	s_Type__typeChart[4][7] = 0.5;
	s_Type__typeChart[4][8] = 2.0;
	s_Type__typeChart[4][9] = 0.5;
	s_Type__typeChart[4][10] = 1.0;
	s_Type__typeChart[4][11] = 0.5;
	s_Type__typeChart[4][12] = 2.0;
	s_Type__typeChart[4][13] = 1.0;
	s_Type__typeChart[4][14] = 0.5;
	s_Type__typeChart[4][15] = 1.0;
	s_Type__typeChart[4][16] = 0.5;
	s_Type__typeChart[5][0] = 1.0;
	s_Type__typeChart[5][1] = 0.5;
	s_Type__typeChart[5][2] = 0.5;
	s_Type__typeChart[5][3] = 1.0;
	s_Type__typeChart[5][4] = 2.0;
	s_Type__typeChart[5][5] = 0.5;
	s_Type__typeChart[5][6] = 1.0;
	s_Type__typeChart[5][7] = 1.0;
	s_Type__typeChart[5][8] = 2.0;
	s_Type__typeChart[5][9] = 2.0;
	s_Type__typeChart[5][10] = 1.0;
	s_Type__typeChart[5][11] = 1.0;
	s_Type__typeChart[5][12] = 1.0;
	s_Type__typeChart[5][13] = 1.0;
	s_Type__typeChart[5][14] = 2.0;
	s_Type__typeChart[5][15] = 1.0;
	s_Type__typeChart[5][16] = 0.5;
	s_Type__typeChart[6][0] = 2.0;
	s_Type__typeChart[6][1] = 1.0;
	s_Type__typeChart[6][2] = 1.0;
	s_Type__typeChart[6][3] = 1.0;
	s_Type__typeChart[6][4] = 1.0;
	s_Type__typeChart[6][5] = 2.0;
	s_Type__typeChart[6][6] = 1.0;
	s_Type__typeChart[6][7] = 0.5;
	s_Type__typeChart[6][8] = 1.0;
	s_Type__typeChart[6][9] = 0.5;
	s_Type__typeChart[6][10] = 0.5;
	s_Type__typeChart[6][11] = 0.5;
	s_Type__typeChart[6][12] = 2.0;
	s_Type__typeChart[6][13] = 0.0;
	s_Type__typeChart[6][14] = 1.0;
	s_Type__typeChart[6][15] = 2.0;
	s_Type__typeChart[6][16] = 2.0;
	s_Type__typeChart[7][0] = 1.0;
	s_Type__typeChart[7][1] = 1.0;
	s_Type__typeChart[7][2] = 1.0;
	s_Type__typeChart[7][3] = 1.0;
	s_Type__typeChart[7][4] = 2.0;
	s_Type__typeChart[7][5] = 1.0;
	s_Type__typeChart[7][6] = 1.0;
	s_Type__typeChart[7][7] = 0.5;
	s_Type__typeChart[7][8] = 0.5;
	s_Type__typeChart[7][9] = 1.0;
	s_Type__typeChart[7][10] = 1.0;
	s_Type__typeChart[7][11] = 1.0;
	s_Type__typeChart[7][12] = 0.5;
	s_Type__typeChart[7][13] = 0.5;
	s_Type__typeChart[7][14] = 1.0;
	s_Type__typeChart[7][15] = 1.0;
	s_Type__typeChart[7][16] = 0.0;
	s_Type__typeChart[8][0] = 1.0;
	s_Type__typeChart[8][1] = 2.0;
	s_Type__typeChart[8][2] = 1.0;
	s_Type__typeChart[8][3] = 2.0;
	s_Type__typeChart[8][4] = 0.5;
	s_Type__typeChart[8][5] = 1.0;
	s_Type__typeChart[8][6] = 1.0;
	s_Type__typeChart[8][7] = 2.0;
	s_Type__typeChart[8][8] = 1.0;
	s_Type__typeChart[8][9] = 0.0;
	s_Type__typeChart[8][10] = 1.0;
	s_Type__typeChart[8][11] = 0.5;
	s_Type__typeChart[8][12] = 2.0;
	s_Type__typeChart[8][13] = 1.0;
	s_Type__typeChart[8][14] = 1.0;
	s_Type__typeChart[8][15] = 1.0;
	s_Type__typeChart[8][16] = 2.0;
	s_Type__typeChart[9][0] = 1.0;
	s_Type__typeChart[9][1] = 1.0;
	s_Type__typeChart[9][2] = 1.0;
	s_Type__typeChart[9][3] = 0.5;
	s_Type__typeChart[9][4] = 2.0;
	s_Type__typeChart[9][5] = 1.0;
	s_Type__typeChart[9][6] = 2.0;
	s_Type__typeChart[9][7] = 1.0;
	s_Type__typeChart[9][8] = 1.0;
	s_Type__typeChart[9][9] = 1.0;
	s_Type__typeChart[9][10] = 1.0;
	s_Type__typeChart[9][11] = 2.0;
	s_Type__typeChart[9][12] = 0.5;
	s_Type__typeChart[9][13] = 1.0;
	s_Type__typeChart[9][14] = 1.0;
	s_Type__typeChart[9][15] = 1.0;
	s_Type__typeChart[9][16] = 0.5;
	s_Type__typeChart[10][0] = 1.0;
	s_Type__typeChart[10][1] = 1.0;
	s_Type__typeChart[10][2] = 1.0;
	s_Type__typeChart[10][3] = 1.0;
	s_Type__typeChart[10][4] = 1.0;
	s_Type__typeChart[10][5] = 1.0;
	s_Type__typeChart[10][6] = 2.0;
	s_Type__typeChart[10][7] = 2.0;
	s_Type__typeChart[10][8] = 1.0;
	s_Type__typeChart[10][9] = 1.0;
	s_Type__typeChart[10][10] = 0.5;
	s_Type__typeChart[10][11] = 1.0;
	s_Type__typeChart[10][12] = 1.0;
	s_Type__typeChart[10][13] = 1.0;
	s_Type__typeChart[10][14] = 1.0;
	s_Type__typeChart[10][15] = 0.0;
	s_Type__typeChart[10][16] = 0.5;
	s_Type__typeChart[11][0] = 1.0;
	s_Type__typeChart[11][1] = 0.5;
	s_Type__typeChart[11][2] = 1.0;
	s_Type__typeChart[11][3] = 1.0;
	s_Type__typeChart[11][4] = 2.0;
	s_Type__typeChart[11][5] = 1.0;
	s_Type__typeChart[11][6] = 0.5;
	s_Type__typeChart[11][7] = 0.5;
	s_Type__typeChart[11][8] = 1.0;
	s_Type__typeChart[11][9] = 0.5;
	s_Type__typeChart[11][10] = 2.0;
	s_Type__typeChart[11][11] = 1.0;
	s_Type__typeChart[11][12] = 1.0;
	s_Type__typeChart[11][13] = 0.5;
	s_Type__typeChart[11][14] = 1.0;
	s_Type__typeChart[11][15] = 2.0;
	s_Type__typeChart[11][16] = 0.5;
	s_Type__typeChart[12][0] = 1.0;
	s_Type__typeChart[12][1] = 2.0;
	s_Type__typeChart[12][2] = 1.0;
	s_Type__typeChart[12][3] = 1.0;
	s_Type__typeChart[12][4] = 1.0;
	s_Type__typeChart[12][5] = 2.0;
	s_Type__typeChart[12][6] = 0.5;
	s_Type__typeChart[12][7] = 1.0;
	s_Type__typeChart[12][8] = 0.5;
	s_Type__typeChart[12][9] = 2.0;
	s_Type__typeChart[12][10] = 1.0;
	s_Type__typeChart[12][11] = 2.0;
	s_Type__typeChart[12][12] = 1.0;
	s_Type__typeChart[12][13] = 1.0;
	s_Type__typeChart[12][14] = 1.0;
	s_Type__typeChart[12][15] = 1.0;
	s_Type__typeChart[12][16] = 0.5;
	s_Type__typeChart[13][0] = 0.0;
	s_Type__typeChart[13][1] = 1.0;
	s_Type__typeChart[13][2] = 1.0;
	s_Type__typeChart[13][3] = 1.0;
	s_Type__typeChart[13][4] = 1.0;
	s_Type__typeChart[13][5] = 1.0;
	s_Type__typeChart[13][6] = 1.0;
	s_Type__typeChart[13][7] = 1.0;
	s_Type__typeChart[13][8] = 1.0;
	s_Type__typeChart[13][9] = 1.0;
	s_Type__typeChart[13][10] = 2.0;
	s_Type__typeChart[13][11] = 1.0;
	s_Type__typeChart[13][12] = 1.0;
	s_Type__typeChart[13][13] = 2.0;
	s_Type__typeChart[13][14] = 1.0;
	s_Type__typeChart[13][15] = 0.5;
	s_Type__typeChart[13][16] = 0.5;
	s_Type__typeChart[14][0] = 1.0;
	s_Type__typeChart[14][1] = 1.0;
	s_Type__typeChart[14][2] = 1.0;
	s_Type__typeChart[14][3] = 1.0;
	s_Type__typeChart[14][4] = 1.0;
	s_Type__typeChart[14][5] = 1.0;
	s_Type__typeChart[14][6] = 1.0;
	s_Type__typeChart[14][7] = 1.0;
	s_Type__typeChart[14][8] = 1.0;
	s_Type__typeChart[14][9] = 1.0;
	s_Type__typeChart[14][10] = 1.0;
	s_Type__typeChart[14][11] = 1.0;
	s_Type__typeChart[14][12] = 1.0;
	s_Type__typeChart[14][13] = 1.0;
	s_Type__typeChart[14][14] = 2.0;
	s_Type__typeChart[14][15] = 1.0;
	s_Type__typeChart[14][16] = 0.5;
	s_Type__typeChart[15][0] = 1.0;
	s_Type__typeChart[15][1] = 1.0;
	s_Type__typeChart[15][2] = 1.0;
	s_Type__typeChart[15][3] = 1.0;
	s_Type__typeChart[15][4] = 1.0;
	s_Type__typeChart[15][5] = 1.0;
	s_Type__typeChart[15][6] = 0.5;
	s_Type__typeChart[15][7] = 1.0;
	s_Type__typeChart[15][8] = 1.0;
	s_Type__typeChart[15][9] = 1.0;
	s_Type__typeChart[15][10] = 2.0;
	s_Type__typeChart[15][11] = 1.0;
	s_Type__typeChart[15][12] = 1.0;
	s_Type__typeChart[15][13] = 2.0;
	s_Type__typeChart[15][14] = 1.0;
	s_Type__typeChart[15][15] = 0.5;
	s_Type__typeChart[15][16] = 0.5;
	s_Type__typeChart[16][0] = 1.0;
	s_Type__typeChart[16][1] = 0.5;
	s_Type__typeChart[16][2] = 0.5;
	s_Type__typeChart[16][3] = 0.5;
	s_Type__typeChart[16][4] = 1.0;
	s_Type__typeChart[16][5] = 2.0;
	s_Type__typeChart[16][6] = 1.0;
	s_Type__typeChart[16][7] = 1.0;
	s_Type__typeChart[16][8] = 1.0;
	s_Type__typeChart[16][9] = 1.0;
	s_Type__typeChart[16][10] = 1.0;
	s_Type__typeChart[16][11] = 1.0;
	s_Type__typeChart[16][12] = 2.0;
	s_Type__typeChart[16][13] = 1.0;
	s_Type__typeChart[16][14] = 1.0;
	s_Type__typeChart[16][15] = 1.0;
	s_Type__typeChart[16][16] = 0.5;
	return true;
}

string Type__toString(int this){
	if(this == -1){
		return "none";
	}
	return s_Type__type_names[this];
}

fixed Type__getAdvantage(int this,int defending){
	if(defending == -1){
		return 1.0;
	}
	return s_Type__typeChart[this][defending];
}

//Static init
bool init___global3(bool A__1,bool A__2){
	s_Kind__kind_names[0] = "PHYSICAL";
	s_Kind__kind_names[1] = "SPECIAL";
	return true;
}

string Kind__toString(int this){
	return s_Kind__kind_names[this];
}

//Constructor for class Move
int new__Move(int A__class,string name,int power,int type,int kind){
	int this=alloc___Move(A__class);
	Move___memory[this].Move__name = name;
	Move___memory[this].Move__power = power;
	Move___memory[this].Move__type = type;
	Move___memory[this].Move__kind = kind;
	return this;
}

string Move__toString(int this){
	return Move___memory[this].Move__name + ", power " + IntToString(Move___memory[this].Move__power) + ", " + Type__toString(Move___memory[this].Move__type) + " type, " + Kind__toString(Move___memory[this].Move__kind);
}

int s_PokemonSpecies__getSpecies(){
	if(s_PokemonSpecies__species == 0){
		s_PokemonSpecies__species = new__ArrayList__1(MC___ArrayList,100);
		ArrayList__addLast(s_PokemonSpecies__species,new__PokemonSpecies(MC___PokemonSpecies,"Charizard", 78, 84, 78, 109, 85, 1, 9, s_Move__FLAMETHROWER));
		ArrayList__addLast(s_PokemonSpecies__species,new__PokemonSpecies__1(MC___PokemonSpecies,"Pikachu", 35, 55, 30, 50, 40, 3, s_Move__GENERIC));
		ArrayList__addLast(s_PokemonSpecies__species,new__PokemonSpecies__1(MC___PokemonSpecies,"Chikorita", 45, 49, 65, 49, 65, 4, s_Move__RAZOR_LEAF));
		ArrayList__addLast(s_PokemonSpecies__species,new__PokemonSpecies__1(MC___PokemonSpecies,"Squirtle", 44, 48, 65, 50, 64, 2, s_Move__WATER_GUN));
		ArrayList__addLast(s_PokemonSpecies__species,new__PokemonSpecies(MC___PokemonSpecies,"Gengar", 60, 65, 60, 130, 75, 13, 7, s_Move__SHADOW_BALL));
		ArrayList__addLast(s_PokemonSpecies__species,new__PokemonSpecies__1(MC___PokemonSpecies,"Blastoise", 79, 83, 100, 85, 105, 2, s_Move__HYDRO_PUMP));
	}
	return s_PokemonSpecies__species;
}

int s_PokemonSpecies__fromString(string name){
	int i;
	int s;
	//generated for-loop
	i = 0;
	while(i < ArrayList__size(s_PokemonSpecies__species)){
		s = ArrayList__getIndex(s_PokemonSpecies__species,i);
		if(PokemonSpecies___memory[s].PokemonSpecies__name == name){
			return s;
		}
		
		i += 1;
	}
	return 0;
}

//Constructor for class PokemonSpecies
int new__PokemonSpecies(int A__class,string name,int hp,int atk,int def,int satk,int sdef,int type1,int type2,int move){
	int this=alloc___PokemonSpecies(A__class);
	PokemonSpecies___memory[this].PokemonSpecies__name = name;
	PokemonSpecies___memory[this].PokemonSpecies__hp = hp;
	PokemonSpecies___memory[this].PokemonSpecies__atk = atk;
	PokemonSpecies___memory[this].PokemonSpecies__def = def;
	PokemonSpecies___memory[this].PokemonSpecies__satk = satk;
	PokemonSpecies___memory[this].PokemonSpecies__sdef = sdef;
	PokemonSpecies___memory[this].PokemonSpecies__type1 = type1;
	PokemonSpecies___memory[this].PokemonSpecies__type2 = type2;
	PokemonSpecies___memory[this].PokemonSpecies__move = move;
	return this;
}

//Constructor for class PokemonSpecies
int new__PokemonSpecies__1(int A__class,string name,int hp,int atk,int def,int satk,int sdef,int type,int move){
	int this=new__PokemonSpecies(A__class,name, hp, atk, def, satk, sdef, type, -1, move);
	return this;
}

int AbstractList__getIterator(int this){
	return AbstractList__getListIteratorAt(this,0);
}

int AbstractList__getListIteratorAt(int this,int index){
	if(index < 0 || index > vcall___List__size(this)){
		s_System__error("Index Out Of Bounds in a.util.AbstractList.getListIteratorAt(int) @" + IntToString(this) + ": " + IntToString(index));
		return 0;
	} else {
		return new__AbstractListIterator(MC___AbstractListIterator,this, index);
	}
}

//Constructor for class AbstractListIterator
int new__AbstractListIterator(int A__class,int list,int pos){
	int this=alloc___Iterator(A__class);
	Iterator___memory[this].AbstractListIterator__list_mult = list;
	Iterator___memory[this].AbstractListIterator__nextIndex_mult = pos;
	Iterator___memory[this].AbstractListIterator__prevIndex = pos - 1;
	Iterator___memory[this].AbstractListIterator__lastIndex = -1;
	return this;
}

bool AbstractListIterator__hasNext(int this){
	return Iterator___memory[this].AbstractListIterator__nextIndex_mult < vcall___List__size(Iterator___memory[this].AbstractListIterator__list_mult);
}

int AbstractListIterator__next(int this){
	int temp;
	if(AbstractListIterator__hasNext(this)){
		Iterator___memory[this].AbstractListIterator__lastIndex = Iterator___memory[this].AbstractListIterator__nextIndex_mult;
		Iterator___memory[this].AbstractListIterator__nextIndex_mult += 1;
		Iterator___memory[this].AbstractListIterator__prevIndex += 1;
		temp = vcall___List__getIndex(Iterator___memory[this].AbstractListIterator__list_mult,Iterator___memory[this].AbstractListIterator__lastIndex);
		return temp;
	} else {
		s_System__error("No Such Element in a.util.AbstractList.AbstractListIterator.next() @" + IntToString(this));
		return 0;
	}
}

//Static init
bool init___global4(bool A__1,bool A__2){
	s_Heap__initHeap();
	return true;
}

void s_Heap__initHeap(){
	int i;
	//generated for-loop
	i = 1;
	while(i <= 14){
		s_Heap__initLevel(i);
		
		i += 1;
	}
	s_Heap__add(14, 0);
}

void s_Heap__initLevel(int level){
	s_Heap__head[level] = 16384 + 2 * (level - 1);
	s_Heap__setHeader(s_Heap__head[level], level, s_Heap__head[level], s_Heap__head[level]);
	s_Heap__count[level] = 0;
}

int s_Heap__level(int ptr){
	return (s_Heap__array[ptr] >> 27) & 31;
}

int s_Heap__prev(int ptr){
	return s_Heap__array[ptr] & 134217727;
}

int s_Heap__next(int ptr){
	return s_Heap__array[ptr + 1];
}

void s_Heap__setHeader(int ptr,int level,int prev,int next){
	s_Heap__array[ptr] = (level << 27) | prev;
	s_Heap__array[ptr + 1] = next;
}

void s_Heap__setPrev(int ptr,int prev){
	s_Heap__array[ptr] = (s_Heap__array[ptr] & -134217728) | prev;
}

void s_Heap__setNext(int ptr,int next){
	s_Heap__array[ptr + 1] = next;
}

bool s_Heap__isEmpty(int level){
	return s_Heap__count[level] == 0;
}

void s_Heap__add(int level,int ptr){
	int next = s_Heap__next(s_Heap__head[level]);
	s_Heap__setNext(s_Heap__head[level], ptr);
	s_Heap__setPrev(next, ptr);
	s_Heap__setHeader(ptr, level, s_Heap__head[level], next);
	s_Heap__count[level] = s_Heap__count[level] + 1;
}

int s_Heap__remove(int level){
	int prev = s_Heap__prev(s_Heap__head[level]);
	s_Heap__remove__1(level, prev);
	return prev;
}

void s_Heap__remove__1(int level,int ptr){
	int prev = s_Heap__prev(ptr);
	int next = s_Heap__next(ptr);
	s_Heap__setNext(prev, next);
	s_Heap__setPrev(next, prev);
	s_Heap__count[level] = s_Heap__count[level] - 1;
}

int s_Heap__buddy(int level,int ptr){
	if((ptr & (1 << level)) == 0){
		return ptr | (1 << level);
	} else {
		return ptr & ~(1 << level);
	}
}

int s_Heap__minLevel(int size){
	int level = 1;
	while(size != 1){
		size = size >> 1;
		level += 1;
	}
	return level;
}

int s_Heap__maxSize(int level){
	return (1 << level) - 1;
}

int s_Heap__round(int size){
	return s_Heap__maxSize(s_Heap__minLevel(size));
}

int s_Heap__malloc(int size){
	int level;
	int i;
	int ptr;
	int right;
	if(size <= 0){
		return -1;
	}
	level = s_Heap__minLevel(size);
	i = level;
	while(i <= 14 && s_Heap__isEmpty(i)){
		i += 1;
	}
	if(i > 14){
		s_System__error("Could not allocate memory in Heap.");
		return -1;
	}
	ptr = s_Heap__remove(i);
	while(i > level){
		i -= 1;
		right = s_Heap__buddy(i, ptr);
		s_Heap__add(i, right);
	}
	s_Heap__array[ptr] = level;
	return ptr + 1;
}

void s_Heap__free(int ptr){
	int level;
	int buddy;
	ptr -= 1;
	level = s_Heap__array[ptr];
	while(level < 14){
		buddy = s_Heap__buddy(level, ptr);
		if(s_Heap__level(buddy) == level){
			s_Heap__remove__1(level, buddy);
			if(buddy < ptr){
				ptr = buddy;
			}
			level += 1;
		} else {
			break;
		}
	}
	s_Heap__add(level, ptr);
}

int s_Heap__realloc(int ptr,int size){
	int ptr2 = s_Heap__malloc(size);
	int min;
	int i;
	if(ptr2 != -1){
		min = s_Heap__maxSize(s_Heap__array[ptr - 1]);
		if(min > size){
			min = size;
		}
		//generated for-loop
		i = 0;
		while(i < min){
			s_Heap__array[ptr2 + i] = s_Heap__array[ptr + i];
			
			i += 1;
		}
		s_Heap__free(ptr);
	}
	return ptr2;
}

void s_Heap__copy(int src,int dest,int len){
	int i;
	if(dest > src && dest - src < len){
		//generated for-loop
		i = len - 1;
		while(i >= 0){
			s_Heap__array[dest + i] = s_Heap__array[src + i];
			
			i -= 1;
		}
	} else {
		//generated for-loop
		i = 0;
		while(i < len){
			s_Heap__array[dest + i] = s_Heap__array[src + i];
			
			i += 1;
		}
	}
}

//Constructor for class ArrayList
int new__ArrayList(int A__class){
	int this=new__ArrayList__1(A__class,7);
	return this;
}

//Constructor for class ArrayList
int new__ArrayList__1(int A__class,int capacity){
	int this=alloc___Iterable(A__class);
	Iterable___memory[this].ArraySet__size_mult = s_Heap__round(capacity);
	Iterable___memory[this].ArraySet__list_mult = s_Heap__malloc(Iterable___memory[this].ArraySet__size_mult);
	Iterable___memory[this].ArrayList__size = 0;
	return this;
}

int ArrayList__size(int this){
	return Iterable___memory[this].ArrayList__size;
}

bool ArrayList__setCapacity(int this,int capacity){
	int ptr;
	capacity = s_Heap__round(capacity);
	ptr = s_Heap__realloc(Iterable___memory[this].ArraySet__list_mult, capacity);
	if(ptr == -1){
		return false;
	}
	Iterable___memory[this].ArraySet__list_mult = ptr;
	Iterable___memory[this].ArraySet__size_mult = capacity;
	return true;
}

bool ArrayList__ensureCapacity(int this,int capacity){
	if(capacity < Iterable___memory[this].ArraySet__size_mult){
		return true;
	}
	return ArrayList__setCapacity(this,capacity);
}

int ArrayList__getIndex(int this,int index){
	if(index < 0 || index >= Iterable___memory[this].ArrayList__size){
		return 0;
	}
	return s_Heap__array[Iterable___memory[this].ArraySet__list_mult + index];
}

void ArrayList__setIndex(int this,int index,int element){
	if(index < 0 || index >= Iterable___memory[this].ArrayList__size){
		return;
	}
	s_Heap__array[Iterable___memory[this].ArraySet__list_mult + index] = element;
}

bool ArrayList__addLast(int this,int element){
	if(Iterable___memory[this].ArrayList__size == Iterable___memory[this].ArraySet__size_mult){
		if(!ArrayList__ensureCapacity(this,Iterable___memory[this].ArrayList__size + 1)){
			return false;
		}
	}
	s_Heap__array[Iterable___memory[this].ArraySet__list_mult + Iterable___memory[this].ArrayList__size] = element;
	Iterable___memory[this].ArrayList__size += 1;
	return true;
}

bool ArrayList__addIndex(int this,int index,int element){
	if(index < 0 || index > Iterable___memory[this].ArrayList__size){
		s_System__error("ArrayList.addIndex: index = " + IntToString(index) + ", size = " + IntToString(Iterable___memory[this].ArrayList__size));
		return false;
	}
	if(Iterable___memory[this].ArrayList__size == Iterable___memory[this].ArraySet__size_mult){
		if(!ArrayList__ensureCapacity(this,Iterable___memory[this].ArrayList__size + 1)){
			return false;
		}
	}
	s_Heap__copy(Iterable___memory[this].ArraySet__list_mult + index, Iterable___memory[this].ArraySet__list_mult + index + 1, Iterable___memory[this].ArrayList__size - index);
	s_Heap__array[Iterable___memory[this].ArraySet__list_mult + index] = element;
	Iterable___memory[this].ArrayList__size += 1;
	return true;
}

int ArrayList__removeIndex(int this,int index){
	int element;
	if(index < 0 || index > Iterable___memory[this].ArrayList__size){
		return 0;
	}
	element = s_Heap__array[Iterable___memory[this].ArraySet__list_mult + index];
	s_Heap__copy(Iterable___memory[this].ArraySet__list_mult + index + 1, Iterable___memory[this].ArraySet__list_mult + index, Iterable___memory[this].ArrayList__size - index - 1);
	Iterable___memory[this].ArrayList__size -= 1;
	return element;
}

//Constructor for class ArraySet
int new__ArraySet(int A__class){
	int this=alloc___Iterable(A__class);
	Iterable___memory[this].ArraySet__list_mult = new__ArrayList(MC___ArrayList);
	Iterable___memory[this].ArraySet__size_mult = 0;
	return this;
}

int ArraySet__size(int this){
	return Iterable___memory[this].ArraySet__size_mult;
}

void ArraySet__ensure(int this,int e){
	while(e >= ArrayList__size(Iterable___memory[this].ArraySet__list_mult)){
		ArrayList__addLast(Iterable___memory[this].ArraySet__list_mult,0);
	}
}

bool ArraySet__add(int this,int e){
	if(ArraySet__contains(this,e)){
		return false;
	}
	ArrayList__setIndex(Iterable___memory[this].ArraySet__list_mult,e, 1);
	Iterable___memory[this].ArraySet__size_mult += 1;
	return true;
}

bool ArraySet__contains(int this,int e){
	ArraySet__ensure(this,e);
	return ArrayList__getIndex(Iterable___memory[this].ArraySet__list_mult,e) != 0;
}

int ArraySet__getIterator(int this){
	return new__ArraySetIterator(MC___ArraySetIterator,Iterable___memory[this].ArraySet__list_mult);
}

//Constructor for class ArraySetIterator
int new__ArraySetIterator(int A__class,int list){
	int this=alloc___Iterator(A__class);
	Iterator___memory[this].AbstractListIterator__list_mult = list;
	Iterator___memory[this].AbstractListIterator__nextIndex_mult = 0;
	return this;
}

bool ArraySetIterator__hasNext(int this){
	while(Iterator___memory[this].AbstractListIterator__nextIndex_mult < ArrayList__size(Iterator___memory[this].AbstractListIterator__list_mult)){
		if(ArrayList__getIndex(Iterator___memory[this].AbstractListIterator__list_mult,Iterator___memory[this].AbstractListIterator__nextIndex_mult) != 0){
			return true;
		}
		Iterator___memory[this].AbstractListIterator__nextIndex_mult += 1;
	}
	return false;
}

int ArraySetIterator__next(int this){
	int temp = Iterator___memory[this].AbstractListIterator__nextIndex_mult;
	Iterator___memory[this].AbstractListIterator__nextIndex_mult += 1;
	return temp;
}

//Constructor for class ArrayMap
int new__ArrayMap(int A__class){
	int this=alloc___Map(A__class);
	Map___memory[this].ArrayMap__list = new__ArrayList(MC___ArrayList);
	Map___memory[this].ArrayMap__size = 0;
	return this;
}

void ArrayMap__ensure(int this,int key){
	while(key >= ArrayList__size(Map___memory[this].ArrayMap__list)){
		ArrayList__addLast(Map___memory[this].ArrayMap__list,0);
	}
}

int ArrayMap__put(int this,int key,int value){
	int prev = ArrayMap__getValue(this,key);
	if(prev == 0){
		Map___memory[this].ArrayMap__size += 1;
	}
	ArrayList__setIndex(Map___memory[this].ArrayMap__list,key, value);
	if(value == 0){
		Map___memory[this].ArrayMap__size -= 1;
	}
	return prev;
}

int ArrayMap__getValue(int this,int key){
	ArrayMap__ensure(this,key);
	return ArrayList__getIndex(Map___memory[this].ArrayMap__list,key);
}

playergroup s_playergroup__empty(){
	return PlayerGroupEmpty();
}

void playergroup__add(playergroup this,int p){
	PlayerGroupAdd(this, p);
}

unit s_unit__create(string name,int options,int player,point position,fixed angle){
	return UnitGroupUnit(UnitCreate(1, name, options, player, position, angle), 1);
}

point unit__getPosition(unit this){
	return UnitGetPosition(this);
}

void unit__setInfoText(unit this,text p2,text p3,text p4){
	UnitSetInfoText(this, p2, p3, p4);
}

void unit__setPropertyInt(unit this,int p2,int p3){
	UnitSetPropertyInt(this, p2, p3);
}

void unit__setCustomValue(unit this,int p2,fixed p3){
	UnitSetCustomValue(this, p2, p3);
}

fixed unit__getCustomValue(unit this,int p2){
	return UnitGetCustomValue(this, p2);
}

unitref unit__getUnitRef(unit this){
	return UnitRefFromUnit(this);
}

//Constructor for class Pokemon
int new__Pokemon(int A__class,int species,int level,int owner,point p){
	int this=alloc___Pokemon(A__class);
	Pokemon___memory[this].Pokemon__species = species;
	Pokemon___memory[this].Pokemon__level = level;
	Pokemon___memory[this].Pokemon__owner = owner;
	Pokemon___memory[this].Pokemon__hp = Pokemon__getHp(this);
	Pokemon___memory[this].Pokemon___unit = s_unit__create(PokemonSpecies___memory[species].PokemonSpecies__name, 0, owner, p, 0.0);
	unit__setPropertyInt(Pokemon___memory[this].Pokemon___unit,2, Pokemon___memory[this].Pokemon__hp);
	unit__setCustomValue(Pokemon___memory[this].Pokemon___unit,0, IntToFixed(this));
	unit__setInfoText(Pokemon___memory[this].Pokemon___unit,StringToText("Level " + IntToString(level)), StringToText(""), StringToText(""));
	TriggerAddEventUnitDamaged(TriggerCreate("damageUnit"), unit__getUnitRef(Pokemon___memory[this].Pokemon___unit), -1, 0, null);
	return this;
}

int Pokemon__getStat(int this,int base){
	int iv = 31;
	int ev = 0;
	return (iv + 2 * base + ev / 4) * Pokemon___memory[this].Pokemon__level / 100 + 5;
}

int Pokemon__getHp(int this){
	return Pokemon__getStat(this,PokemonSpecies___memory[Pokemon___memory[this].Pokemon__species].PokemonSpecies__hp);
}

int Pokemon__getAtk(int this){
	return Pokemon__getStat(this,PokemonSpecies___memory[Pokemon___memory[this].Pokemon__species].PokemonSpecies__atk);
}

int Pokemon__getDef(int this){
	return Pokemon__getStat(this,PokemonSpecies___memory[Pokemon___memory[this].Pokemon__species].PokemonSpecies__def);
}

int Pokemon__getSAtk(int this){
	return Pokemon__getStat(this,PokemonSpecies___memory[Pokemon___memory[this].Pokemon__species].PokemonSpecies__satk);
}

int Pokemon__getSDef(int this){
	return Pokemon__getStat(this,PokemonSpecies___memory[Pokemon___memory[this].Pokemon__species].PokemonSpecies__sdef);
}

int Pokemon__damage(int this,int other){
	int move = PokemonSpecies___memory[Pokemon___memory[this].Pokemon__species].PokemonSpecies__move;
	fixed attack;
	fixed defense;
	fixed damage;
	fixed effectiveness;
	fixed stab;
	fixed random;
	if(Move___memory[move].Move__kind == 0){
		attack = IntToFixed(Pokemon__getAtk(this));
		defense = IntToFixed(Pokemon__getDef(other));
	} else if(Move___memory[move].Move__kind == 1){
		attack = IntToFixed(Pokemon__getSAtk(this));
		defense = IntToFixed(Pokemon__getSDef(other));
	}
	damage = ((2.0 * IntToFixed(Pokemon___memory[this].Pokemon__level) + 10.0) / 250.0 * attack / defense * IntToFixed(Move___memory[move].Move__power) + 2.0);
	effectiveness = Pokemon__getTypeAdvantage(this,other);
	damage *= effectiveness;
	stab = 1.0;
	if(Move___memory[move].Move__type == PokemonSpecies___memory[Pokemon___memory[this].Pokemon__species].PokemonSpecies__type1 || Move___memory[move].Move__type == PokemonSpecies___memory[Pokemon___memory[this].Pokemon__species].PokemonSpecies__type2){
		stab = 1.5;
	}
	damage *= stab;
	random = 1.0;
	damage *= random;
	return FixedToInt(damage);
}

fixed Pokemon__getTypeAdvantage(int this,int other){
	int attacking = Move___memory[PokemonSpecies___memory[Pokemon___memory[this].Pokemon__species].PokemonSpecies__move].Move__type;
	return Type__getAdvantage(attacking,PokemonSpecies___memory[Pokemon___memory[other].Pokemon__species].PokemonSpecies__type1) * Type__getAdvantage(attacking,PokemonSpecies___memory[Pokemon___memory[other].Pokemon__species].PokemonSpecies__type2);
}

unit Pokemon__getUnit(int this){
	return Pokemon___memory[this].Pokemon___unit;
}

void Pokemon__setUnit(int this,unit u){
	Pokemon___memory[this].Pokemon___unit = u;
}

int Pokemon__clone(int this,int player,point spawn){
	return new__Pokemon(MC___Pokemon,Pokemon___memory[this].Pokemon__species, Pokemon___memory[this].Pokemon__level, player, spawn);
}

int PokemonComparator__compare(int this,int p1,int p2){
	return p1 - p2;
}

int PokemonHasher__hashCode(int this,int p){
	return p;
}

bool PokemonHasher__equal(int this,int p1,int p2){
	return p1 == p2;
}

bool damageUnit(bool conditions,bool actions){
	unit src = EventUnitDamageSourceUnit();
	unit trg = EventUnit();
	int p_src = FixedToInt(unit__getCustomValue(src,0));
	int p_trg = FixedToInt(unit__getCustomValue(trg,0));
	int damage = Pokemon__damage(p_src,p_trg);
	Pokemon___memory[p_trg].Pokemon__hp -= damage;
	if(Pokemon___memory[p_trg].Pokemon__hp < 0){
		Pokemon___memory[p_trg].Pokemon__hp = 0;
		dealloc___Pokemon(p_trg);
	}
	unit__setPropertyInt(trg,0, Pokemon___memory[p_trg].Pokemon__hp);
	return true;
}

string abilcmd__getAbility(abilcmd this){
	return AbilityCommandGetAbility(this);
}

void makeRentalCenter(int player){
	unit u = s_unit__create("RentalCenter", 0, player, Player__get__startLocation(player), 0.0);
	trigger t = s_trigger__create("rent");
	int speciesList = s_PokemonSpecies__getSpecies();
	int i;
	int species;
	//generated for-loop
	i = 0;
	while(i < ArrayList__size(speciesList)){
		species = ArrayList__getIndex(speciesList,i);
		trigger__addEventUnitAbility(t,unit__getUnitRef(u), AbilityCommand(PokemonSpecies___memory[species].PokemonSpecies__name, 0), -6, false);
		
		i += 1;
	}
}

bool rent(bool conditions,bool actions){
	string abilName = abilcmd__getAbility(EventUnitAbility());
	int player = EventPlayer();
	s_Trainer__addPokemon__1(player, s_PokemonSpecies__fromString(abilName));
	return true;
}

void initTrainer(int player,int team){
	int p = player;
	if(!Player__isActive(p)){
		return;
	}
	Team__addTrainer(team,new__Trainer(MC___Trainer,p, team));
	s_System__debug("Added player " + Player__toString(p) + " to " + Team___memory[team].Team__name);
	makeRentalCenter(p);
	CameraPan(player, Player__get__startLocation(p), 0.0, 0.0, 0.0, false);
}

//Static init
bool init___global5(bool A__1,bool A__2){
	int centerX;
	s_Team__left = new__Team(MC___Team,"Left Team", Point(8.0, 36.0), 9);
	s_Team__right = new__Team(MC___Team,"Right Team", Point(136.0, 36.0), 10);
	centerX = 72;
	Team___memory[s_Team__left].Team__enemy = s_Team__right;
	Team___memory[s_Team__right].Team__enemy = s_Team__left;
	s_Trainer__trainers = new__ArrayMap(MC___ArrayMap);
	initTrainer(1, s_Team__left);
	initTrainer(2, s_Team__left);
	initTrainer(3, s_Team__right);
	initTrainer(4, s_Team__right);
	libNtve_gf_SetPlayerGroupAlliance(Team___memory[s_Team__left].Team__group, 2);
	libNtve_gf_SetPlayerGroupAlliance(Team___memory[s_Team__right].Team__group, 2);
	return true;
}

//Constructor for class Team
int new__Team(int A__class,string name,point spawn,int cpu){
	int this=alloc___Team(A__class);
	Team___memory[this].Team__name = name;
	Team___memory[this].Team__spawn = spawn;
	Team___memory[this].Team__cpu = cpu;
	Team___memory[this].Team__group = s_playergroup__empty();
	playergroup__add(Team___memory[this].Team__group,cpu);
	Team___memory[this].Team__trainers = new__ArraySet(MC___ArraySet);
	return this;
}

int Team__size(int this){
	return vcall___Set__size(Team___memory[this].Team__trainers);
}

string Team__toString(int this){
	return Team___memory[this].Team__name;
}

void Team__addTrainer(int this,int trainer){
	vcall___Set__add(Team___memory[this].Team__trainers,trainer);
	playergroup__add(Team___memory[this].Team__group,Trainer___memory[trainer].Trainer__player);
}

int s_Trainer__getTrainer(int player){
	return vcall___Map__getValue(s_Trainer__trainers,player);
}

//Constructor for class Trainer
int new__Trainer(int A__class,int player,int team){
	int this=alloc___Trainer(A__class);
	Trainer___memory[this].Trainer__player = player;
	Player__set__minerals(player,100);
	Trainer___memory[this].Trainer__team = team;
	Trainer___memory[this].Trainer__pokemon = new__ArraySet(MC___ArraySet);
	vcall___Map__put(s_Trainer__trainers,player, this);
	return this;
}

void Trainer__addPokemon(int this,int species){
	vcall___Set__add(Trainer___memory[this].Trainer__pokemon,new__Pokemon(MC___Pokemon,species, 10, Trainer___memory[this].Trainer__player, Team___memory[Trainer___memory[this].Trainer__team].Team__spawn));
}

void s_Trainer__addPokemon__1(int player,int species){
	Trainer__addPokemon(vcall___Map__getValue(s_Trainer__trainers,player),species);
}

//Static init
bool init___global6(bool A__1,bool A__2){
	timer t;
	VisEnable(1, false);
	t = s_timer__create();
	timer__start(t,15.0, true, 0);
	trigger__addEventTimer(s_trigger__create("makeWave"),t);
	return true;
}

bool createUnitChat(bool b1,bool b2){
	string chat = EventChatMessage(false);
	int species = s_PokemonSpecies__fromString(chat);
	int player;
	int trainer;
	if(species == 0){
		s_System__print("Species " + chat + " does not exist!");
		return false;
	}
	player = EventPlayer();
	trainer = s_Trainer__getTrainer(player);
	Trainer__addPokemon(trainer,species);
	return true;
}

bool makeWave(bool b1,bool b2){
	waveHelper(s_Team__left, 1);
	waveHelper(s_Team__right, -1);
	return true;
}

void waveHelper(int team,int dx){
	int spawn_dx = 18 * dx;
	int attack_dx = 100 * dx;
	int trainers = vcall___Iterable__getIterator(Team___memory[team].Team__trainers);
	int trainer;
	int pokemon;
	int p;
	point spawn;
	int clone;
	point attack;
	order o;
	while(vcall___Iterator__hasNext(trainers)){
		trainer = vcall___Iterator__next(trainers);
		pokemon = vcall___Iterable__getIterator(Trainer___memory[trainer].Trainer__pokemon);
		while(vcall___Iterator__hasNext(pokemon)){
			p = vcall___Iterator__next(pokemon);
			spawn = point__translateXY(unit__getPosition(Pokemon__getUnit(p)),IntToFixed(spawn_dx), 0.0);
			clone = Pokemon__clone(p,Team___memory[Trainer___memory[trainer].Trainer__team].Team__cpu, spawn);
			attack = point__translateXY(spawn,IntToFixed(attack_dx), 0.0);
			o = OrderTargetingPoint(AbilityCommand("attack", 0), attack);
			UnitIssueOrder(Pokemon__getUnit(clone), o, 1);
		}
		dealloc___Iterator(pokemon);
	}
	dealloc___Iterator(trainers);
}

void initAndromeda(){
	trigger t;
	A__classInit();
	t = TriggerCreate("init___global1");
	TriggerAddEventMapInit(t);
	t = TriggerCreate("init___global4");
	TriggerAddEventMapInit(t);
	t = TriggerCreate("init___global5");
	TriggerAddEventMapInit(t);
	t = TriggerCreate("init___global2");
	TriggerAddEventMapInit(t);
	t = TriggerCreate("init___global3");
	TriggerAddEventMapInit(t);
	t = TriggerCreate("init___global6");
	TriggerAddEventMapInit(t);
}


